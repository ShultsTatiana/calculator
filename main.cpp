#include <iostream>
#include <stack>
#include <string>

#include <vector>
#include <sstream>
using namespace std;

/*
* ПРИНЦИП РАБОТЫ АЛГОРИТМА
* Алгоритм реализуется в 2-х функциях:
*	processingData - принимает потоки ввода-вывода (нужно для тестирования),
*					 обрабатывает ввод и выводит результат в поток вывода
*	getOperation - принимает два операнда и символ операции.
*				   Возвращает результат обработки операции.
*				   Учитывает, что при '/' - округление к минус бесконечности.
*
* Для работы алгоритма потребуется считать символ(операнд или операцию) из потока
*	(читаем символ(string) из потока, пока это возможно),
*	и определить, что делать: произвести операцию или сохранить операнд.
* Если считан операнд - кладем его в предварительно заведенный стек numbers.
* Если считана операция - вызываем getOperation - найдем результат операции
* с последними двумя числами из стека numbers и результат кладем в стек numbers.
*
* Если корректность обратной польской нотации на входе гарантирована,
* то до последней операции в стеке всегда будет лежать как минимум 2 числа:
*		- либо числа считанные из потока
*		- либо число из потока и результат операции и наоборот
*		- либо два результата операции
* Последняя операция оставит в стеке одно число - результат выражения.
*
* Дополнительно:
*	Операндами могут быть положительные или отрицательные числа.
*	Отрицательные числа начиснаются с символа '-' и их длинна(размер) всегда >1.
*	Положительные числа могут содержать всего один символ, как и операции,
*		но первый символ числа всегда цифра.
*	Опрераясь на гарантии условий задачи, проверяем 3 случая:
*		- отрицательное число (начинается с '-', длинна строго больше единицы)
*		- положительное число (начинается с цифры '0'-'9')
*		- операция (все остальное '+', '-', '*', '/')
*
* Вычислительная сложность алгоритма:
* Линейная O(n), или const*O(n), где
*	n - длинна строки выражения (в символах)
*		(так или иначе в while считает все символы строки выражения)
*	const -
*		первый if, .size() строки и .push в стек - const
*		второй else if, isdigit и .push в стек - const
*		третий else - .top(), .pop() в стек - const
*					  getOperation(...) - const
*		
* Для численной оценки в задаче недостаточно данных.
*
* Пространственная сложность алгоритма:
* int: 4B (от −2'147'483'648 до 2'147'483'647)
* char: 1B (один символ в кодировке ASCII)
* string: размер занимаемый самим контейнером и его методами мне не известен
*	в string хранятся данные типа char. Значит на каждой итерации в худшем случае
*	в нем будет храниться максимум 6 char (числа, по модулю не превосходящие 10'000)
* stack<int>: размер занимаемый самим контейнером и его методами мне не известен
*	Однако можно оценить размер хранимых в нем чисел для худшего случая.
*	Если всего нужно будет произвести N операций, и все они стоят в конце
*	выражения, то стек будет содержать N + 1 число.
* Если считать расходы на храние считываемого символа(string) и int(right,left) много меньшими N
* пространственную сложность можно оценить как линейную:
*	O(N)	(N+1)*int +(N+1)*указатель_на_int + const(string, контейнер stak и прочие переменные) =
*			= (N+1)*4B +(N+1)*8B = (N+1)*12B
*/

int getOperation(int left, int right, char operation) {
	int result(0);
	// Доступные операции: '+', '-', '*', '/'
	if (operation == '+') {
		result = left + right;
	}
	else if (operation == '-') {
		result = left - right;
	}
	else if (operation == '*') {
		result = left * right;
	}
	else if (operation == '/') {
		//нам обещали отсутствие деления на ноль, но пусть это "полежит тут"
		if (right != 0) {
			//учтём округление к минус бесконечности 
			if (left < 0) { //для отрицательных чисел с остатком от деления 
				result = left / right - (left % right == 0 ? 0 : 1);
			}
			else {
				result = left / right;
			}
		}
	}
	return result;
}

ostream& processingData(istream& input = std::cin, ostream& out = std::cout) {
	stack<int> numbers;

	string simbol; //для считывания символов: операндов и операций
	simbol.reserve(6); //операнды могут иметь максимальный размер 5 разрядов + '-'

	while (input >> simbol) {
		//все операции имеют размер 1. Все отрицательные числа размер не менее 1
		if (simbol[0] == '-' && simbol.size() > 1) { //отрицательное число
			//https://en.cppreference.com/w/cpp/string/basic_string/stol
			numbers.push(stoi(simbol));
		}
		//положительные числа, как и операции могут иметь размер 1
		//но операции не могут быть числами
		//https://en.cppreference.com/w/cpp/string/byte/isdigit
		else if (isdigit(simbol[0])) {				//положительное число
			numbers.push(stoi(simbol));
		}
		// во всех остальных случаях полагаемся на корректоность ввода
		// те ожидаем на входе только цифры и перчисленные операции
		// помним, что пробелы сожрал input >> simbol, и их не будет
		else { //ожидаем ch == '+' || ch == '-' || ch == '*' || ch == '/'
			int right(numbers.top());	//"наверху" стека лежит правый операнд
			numbers.pop();				//уберем его, оно там больше не нужно
			int left(numbers.top());	//теперь заберём левый операнд
			numbers.pop();				//убираем левый из стека

			numbers.push(getOperation(left, right, simbol[0])); //считаем, кладем в стек
		}
	}

	out << numbers.top() << endl; //сбросим буфер на последок

	return out;
}

struct Test {
	string input;
	string expect;
};

void tests() {
	vector<Test> tests{
		{"2 1 + 3 *\n",	"9\n"},			//0
		{"7 2 + 4 * 2 +\n",	"38\n"},	//1
		{"0 0 +\n",	"0\n"},				//2
		{"-10 3 /\n", "-4\n"},			//3
		{"-10 5 /\n", "-2\n"},			//4
		{"10 3 /\n", "3\n"},			//5
		{"10 5 /\n", "2\n"},			//6
		{"1 1 +\n",	"2\n"},				//7
		{"1 1 -\n",	"0\n"},				//8
		{"1 1 *\n",	"1\n"},				//9
		{"10 1 /\n", "10\n"},			//10
		{"10 2 4 * -\n","2\n"},			//11
		{"1000 -1000 +\n","0\n"},			//12
	};

	size_t failCounter(0), line(0);
	for (Test test : tests) {
		stringstream input(move(test.input));
		stringstream out;

		processingData(input, out);
		string strOutput = out.str();

		if (strOutput != test.expect) {
			++failCounter;
			std::cout << "Test in " << line << "\tis\t" <<
				strOutput << "!= " << test.expect << endl;
		}
		++line;
	}
	std::cout << (failCounter == 0 ? "All tests is Ok\n" : "FAIL\n");
}

int main()
{
	tests();

	processingData();

	return 0;
}
